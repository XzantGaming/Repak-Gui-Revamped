#include <std/string.pat>
#include <std/math.pat>
#include <std/file.pat>
fn get_version_size(){
    return 221;
};
struct Footer{
    u128 encryption_uuid;
    bool is_encrypted;
    u32 magic;
    u32 version;
    u64 index_offset;
    u64 index_size;
    u8 hash[20];
    bool frozen;
    char string[sizeof($) - $];
};

u64 start = sizeof($) - get_version_size();



Footer footer @start;

// INDEX AND FOOTER ARE ENCRYPTED, CREATE DIFFERENT SECTIONS AND LOAD UNENCRYPTED DUMPS FROM REPAK
u8 index[footer.index_size] @ footer.index_offset;
std::mem::Section encrypted_idx = std::mem::create_section("Encrypted index");
std::mem::copy_value_to_section(index,encrypted_idx,0x0);
// export the index from section and run the script now


// RUN THIS ON DECRYPTED INDEX GENERATED BY PYTHON SCRIPT
std::file::Handle decrypted_file = std::file::open("C:\\Users\\natimerry\\RustroverProjects\\repak-rivals\\imhex_patterns\\decrypted_index.bin",1);
u32 decrypted_idx_size = std::file::size(decrypted_file);
std::mem::Section decrypted_idx = std::mem::create_section("Decrypted index");
std::mem::copy_value_to_section(std::file::read(decrypted_file,decrypted_idx_size),decrypted_idx,0x0);

struct DecryptedIndex{
    s32 len;
    char buf[len];
    
    u64 path_hash_seed;
    u32 record_count;
    u32 hash_path_index;
    

    u64 phi_offset;
    u64 phi_size;
    u8 _phi_hash[20];
    
    
    u32 has_fdi;
    u64 fdi_offset;
    u64 full_directory_index_size;
    u8 fdi_hash[20];
        
    u32 encoded_entry_size;
    u8 encoded_entries[encoded_entry_size];
};

DecryptedIndex dx @ 0x00 in decrypted_idx;



u8 path_hash_index_buf[dx.phi_size] @ dx.phi_offset [[color("d06c3b")]];
u8 fdi_buf[dx.full_directory_index_size] @ dx.fdi_offset [[color("e744c9")]];

u8 magic[start - $] @ $ [[color("FF0000")]];


std::mem::Section encrypted_phi = std::mem::create_section("Encrypted phi");
std::mem::copy_value_to_section(path_hash_index_buf,encrypted_phi,0x0);
// export the phi from section and run the script now


// RUN THIS ON DECRYPTED phi GENERATED BY PYTHON SCRIPT
std::file::Handle decrypted_phi_handle = std::file::open("C:\\Users\\natimerry\\RustroverProjects\\repak-rivals\\imhex_patterns\\decrypted_phi.bin",1);
u32 decrypted_phi_size = std::file::size(decrypted_phi_handle);
std::mem::Section decrypted_phi = std::mem::create_section("Decrypted phi");
std::mem::copy_value_to_section(std::file::read(decrypted_file,decrypted_phi_size),decrypted_phi,0x0);


std::mem::Section encrypted_fdi = std::mem::create_section("Encrypted fdi");
std::mem::copy_value_to_section(fdi_buf,encrypted_fdi,0x0);


// RUN THIS ON DECRYPTED fdi GENERATED BY PYTHON SCRIPT
std::file::Handle decrypted_fdi_handle = std::file::open("C:\\Users\\natimerry\\RustroverProjects\\repak-rivals\\imhex_patterns\\decrypted_fdi.bin",1);
u32 decrypted_fdi_size = std::file::size(decrypted_fdi_handle);
std::mem::Section decrypted_fdi = std::mem::create_section("Decrypted fdi");
std::mem::copy_value_to_section(std::file::read(decrypted_fdi_handle,decrypted_fdi_size),decrypted_fdi,0x0);


u32 dir_count @ 0x0 in decrypted_fdi;

struct FileEntry{
    s32 name_len;
    char name[name_len];
    u32 offset;
};

struct DirEntry{
    s32 name_len;
    char name[name_len];
    u32 file_count;
    FileEntry files[file_count];
};



DirEntry dirs[dir_count] @ 0x04 in decrypted_fdi;

u32 total_entries = 0;
u64 begin_dir_entry_offset = 0;
for (u32 i = 0, i < dir_count, i= i+1){
    std::print("Directory Name: {}\n", dirs[i].name);
    std::print("Number of Files: {}\n", dirs[i].file_count);


    for (u32 j = 0, j < dirs[i].file_count,j=j+1) {

        if (begin_dir_entry_offset == 0){
            begin_dir_entry_offset = dirs[i].files[j].offset;
        }
        std::print("  - Name: {}, Offset: {}\n", dirs[i].files[j].name, dirs[i].files[j].offset);
        total_entries += 1;
    }
}


struct Entry {
    u32 bits;

    u32 _compression_bits = (bits >> 23) & 0x3f;

    if (_compression_bits != 0) {
        _compression_bits = _compression_bits - 1;
    }

    u32 _compression_block_size = bits & 0x3f;

    if (_compression_block_size == 0x3f) {
        u32 compression_block_size; // read_u32<LE>
    } else {
        _compression_block_size = _compression_block_size << 11;
    }


    if ((bits & (1 << 31)) != 0) {
        u32 offset;
    } else {
        u64 offset;
    }

    if ((bits & (1 << 30)) != 0) {
        u32 uncompressed;
    } else {
        u64 uncompressed;
    }

    u64 _size =0;
    if (_compression_bits != 0) {
        if ((bits & (1 << 29)) != 0) {
            u32 compressed;
            _size = compressed;
        } else {
            u64 compressed;
            _size = compressed;
        }
    } else {
        _size = uncompressed;
    }

};


std::mem::Section encoded_entries = std::mem::create_section("encoded_entries");
std::mem::copy_value_to_section(dx.encoded_entries,encoded_entries,0x0);

Entry entries[total_entries] @ 0x0 in encoded_entries;

// there is no real way of highlighting file edge boundaries so we need to rely on algorithms for that
// todo: write a python index that generates the shit based on the encoded_index base offset data
